import React, { useEffect, useRef, useState } from "react";
import L from "leaflet";
import "leaflet/dist/leaflet.css";
import "leaflet-draw/dist/leaflet.draw.css";
import "leaflet-draw";

/*
import React, { useEffect, useState } from "react";
import { MapContainer, TileLayer, GeoJSON, useMap } from "react-leaflet";
import L from "leaflet";
import "leaflet/dist/leaflet.css";
import "leaflet-draw/dist/leaflet.draw.css";
import "leaflet-draw";
import { Feature } from "geojson";
*/


// Type augmentations for leaflet-draw
declare module "leaflet" {
  namespace Control {
    class Draw extends Control {
      constructor(options?: any);
    }
  }
  namespace Draw {
    namespace Event {
      const CREATED: string;
      const EDITED: string;
      const DELETED: string;
    }
  }
}
interface Feature {
  id?: string | number;
  type: "Feature";
  geometry: GeoJSON.Geometry;
  properties: Record<string, any>;
}

const listUrl = "http://localhost:3001/api/features";
const saveUrl = "http://localhost:3001/api/features";
const deleteUrl = "http://localhost:3001/features";

const EditableMap: React.FC = () => {
  const mapRef = useRef<L.Map | null>(null);
  const drawnItemsRef = useRef<L.FeatureGroup>(new L.FeatureGroup());
  const [features, setFeatures] = useState<Feature[]>([]);

  // Fetch existing features from backend
  useEffect(() => {
    fetch(listUrl)
      .then((res) => res.json())
      .then((data) => {
        setFeatures(data.features);
      })
      .catch((err) => console.error("Error fetching features", err));
  }, []);

  // Initialize map
  useEffect(() => {
    if (mapRef.current) return;

    const map = L.map("map", {
      center: [21.1458, 79.0882], // Nagpur
      zoom: 8,
    });
    mapRef.current = map;

    // MapTiler basemap (vector rasterized tiles)
    L.tileLayer(
      `https://api.maptiler.com/maps/streets/256/{z}/{x}/{y}.png?key=b59pIgoNGnhNHBDuQlry`,
      {
        attribution:
          '&copy; <a href="https://www.maptiler.com/">MapTiler</a> contributors',
      }
    ).addTo(map);

    // Add drawn items layer
    drawnItemsRef.current.addTo(map);

    // Add Leaflet Draw toolbar
    const drawControl = new L.Control.Draw({
      edit: { featureGroup: drawnItemsRef.current },
      draw: {
        polygon: true,
        polyline: true,
        rectangle: true,
        circle: false,
        marker: true,
      },
    });
    map.addControl(drawControl);

    // Event: Create new feature
    map.on(L.Draw.Event.CREATED, async (e: any) => {
      const layer = e.layer;
      drawnItemsRef.current.addLayer(layer);

      const geojson = layer.toGeoJSON();
      const newFeature: Feature = {
        type: "Feature",
        geometry: geojson.geometry,
        properties: {},
      };

      // Save to backend
      const res = await fetch(saveUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ features: [newFeature] }),
      });
      const result = await res.json();

      if (result.features) {
        setFeatures((prev) => [...prev, ...result.features]);
      }
    });

    // Event: Edit existing feature
    map.on(L.Draw.Event.EDITED, async (e: any) => {
      const layers = e.layers;
      layers.eachLayer(async (layer: any) => {
        const geojson = layer.toGeoJSON();
        const fid = (layer as any).feature?.id;

        if (!fid) return;

        const updatedFeature: Feature = {
          id: fid,
          type: "Feature",
          geometry: geojson.geometry,
          properties: (layer as any).feature?.properties || {},
        };

        await fetch(`${saveUrl}/${fid}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(updatedFeature),
        });

        setFeatures((prev) =>
          prev.map((f) => (f.id === fid ? updatedFeature : f))
        );
      });
    });

    // Event: Delete feature
    map.on(L.Draw.Event.DELETED, async (e: any) => {
      const layers = e.layers;
      layers.eachLayer(async (layer: any) => {
        const fid = (layer as any).feature?.id;
        if (!fid) return;

        await fetch(`${deleteUrl}/${fid}`, { method: "DELETE" });

        setFeatures((prev) => prev.filter((f) => f.id !== fid));
      });
    });
  }, []);

  // Re-render features when state changes
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;

    drawnItemsRef.current.clearLayers();

    features.forEach((f) => {
      const layer = L.geoJSON(f, {
        onEachFeature: (feature, layer) => {
          // Popup for editing properties
          layer.bindPopup(createPopupContent(feature, (updatedProps) => {
            const updatedFeature: Feature = {
              ...f,
              properties: updatedProps,
            };

            // Save properties update
            fetch(`${saveUrl}/${f.id}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updatedFeature),
            });

            setFeatures((prev) =>
              prev.map((x) => (x.id === f.id ? updatedFeature : x))
            );
          }));
        },
      });
      drawnItemsRef.current.addLayer(layer);
    });
  }, [features]);

  // --- Popup content ---
  const createPopupContent = (
    feature: Feature,
    onSave: (props: Record<string, any>) => void
  ) => {
    const container = L.DomUtil.create("div", "popup-container");
    container.style.minWidth = "250px";

    const props = { ...feature.properties };

    const render = () => {
      container.innerHTML = "";

      Object.entries(props).forEach(([key, value]) => {
        const row = document.createElement("div");
        row.style.marginBottom = "5px";

        const keyInput = document.createElement("input");
        keyInput.type = "text";
        keyInput.value = key;
        keyInput.placeholder = "key";

        const valueInput = document.createElement("input");
        valueInput.type = "text";
        valueInput.value = value as string;
        valueInput.placeholder = "value";

        row.appendChild(keyInput);
        row.appendChild(valueInput);

        container.appendChild(row);

        keyInput.addEventListener("input", () => {
          delete props[key];
          props[keyInput.value] = valueInput.value;
        });
        valueInput.addEventListener("input", () => {
          props[keyInput.value] = valueInput.value;
        });
      });

      const addBtn = document.createElement("button");
      addBtn.textContent = "Add field";
      addBtn.onclick = () => {
        props[""] = "";
        render();
      };
      container.appendChild(addBtn);

      const saveBtn = document.createElement("button");
      saveBtn.textContent = "Save";
      saveBtn.style.marginLeft = "10px";
      saveBtn.onclick = () => {
        onSave(props);
      };
      container.appendChild(saveBtn);
    };

    render();
    return container;
  };

  return <div id="map" style={{ height: "100vh", width: "100%" }} />;
};

export default EditableMap;

